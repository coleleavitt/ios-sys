//! Build implementation for ios-sys
//!
//! Generates Rust FFI bindings for:
//! - Public iOS frameworks (from headers via bindgen)
//! - Private iOS frameworks (from TBD files)
//! - Objective-C classes (from runtime introspection)

mod tbd;
mod objc_codegen;

use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use tbd::{TbdInfo, parse_tbd_file};

// ============================================================================
// Bindings Generation
// ============================================================================

fn generate_tbd_bindings(tbd_info: &TbdInfo, module_name: &str, out_path: &Path) {
    let mut output = String::new();

    output.push_str(&format!(
        "// Generated bindings for {} from TBD file\n\
         // These are opaque types and function declarations extracted from symbol information\n\n",
        module_name
    ));

    output.push_str("use core::ffi::c_void;\n");
    output.push_str("use crate::objc::{Class, SEL, IMP};\n\n");

    // Generate Objective-C class declarations as opaque types
    if !tbd_info.objc_classes.is_empty() {
        output.push_str(
            "// ============================================================================\n",
        );
        output.push_str("// Objective-C Classes (opaque types)\n");
        output.push_str(
            "// ============================================================================\n\n",
        );

        for class in &tbd_info.objc_classes {
            output.push_str(&format!(
                "/// Opaque type for Objective-C class `{}`\n\
                 #[repr(C)]\n\
                 pub struct {} {{\n\
                     _private: [u8; 0],\n\
                 }}\n\n",
                class, class
            ));
        }
    }

    // Generate function declarations from symbols
    if !tbd_info.symbols.is_empty() {
        output.push_str(
            "// ============================================================================\n",
        );
        output.push_str("// Exported Symbols\n");
        output.push_str(
            "// ============================================================================\n\n",
        );

        output.push_str("extern \"C\" {\n");

        for symbol in &tbd_info.symbols {
            // Skip internal/linker symbols
            if symbol.starts_with('$') || symbol.starts_with('_') && symbol.len() > 50 {
                continue;
            }

            // Clean up symbol name (remove leading underscore)
            let clean_symbol = symbol.strip_prefix('_').unwrap_or(symbol);

            // Skip OBJC_CLASS_ and OBJC_METACLASS_ (these are handled as classes)
            if clean_symbol.starts_with("OBJC_CLASS_")
                || clean_symbol.starts_with("OBJC_METACLASS_")
            {
                continue;
            }

            // Determine if it's a function or a variable
            // Functions usually don't start with 'k' (constants) or end with certain patterns
            let is_const = clean_symbol.starts_with('k')
                && clean_symbol
                    .chars()
                    .nth(1)
                    .map_or(false, |c| c.is_uppercase());

            if is_const {
                // Export as a constant/static
                output.push_str(&format!(
                    "    pub static {}: *const c_void;\n",
                    clean_symbol
                ));
            } else {
                // Export as a function (with unknown signature)
                output.push_str(&format!(
                    "    // pub fn {}(...);  // Signature unknown - define manually if needed\n",
                    clean_symbol
                ));
            }
        }

        output.push_str("}\n\n");
    }

    // Write the generated bindings
    fs::write(out_path.join(format!("{}.rs", module_name)), output)
        .expect(&format!("Failed to write TBD bindings for {}", module_name));
}

/// Generates a public_frameworks.rs file with module exports for all public frameworks
fn generate_public_framework_modules(frameworks: &[String], out_path: &Path) {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Public Framework Modules (auto-generated from SDK headers)\n");
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// This file is automatically generated by frameworks.rs\n");
    output.push_str("// Do not edit manually - changes will be overwritten\n\n");

    for framework in frameworks {
        // Skip core frameworks that are always included in lib.rs
        if framework == "Foundation" || framework == "CoreFoundation" || framework == "CoreGraphics"
        {
            continue;
        }

        let module_name = framework.to_lowercase().replace("_", "");
        let feature_name = module_name.clone();

        output.push_str(&format!("#[cfg(feature = \"{}\")]\n", feature_name));
        output.push_str(&format!("pub mod {} {{\n", module_name));
        output.push_str(&format!(
            "    //! {} framework bindings (auto-generated from {}/{}.h)\n",
            framework, framework, framework
        ));
        output.push_str("    #![allow(clippy::all)]\n");
        output.push_str("    #![allow(warnings)]\n");
        output.push_str(&format!(
            "    include!(concat!(env!(\"OUT_DIR\"), \"/{}.rs\"));\n",
            module_name
        ));
        output.push_str("}\n\n");
    }

    // Write the file
    fs::write(out_path.join("public_frameworks.rs"), output)
        .expect("Failed to write public_frameworks.rs");

    println!(
        "cargo:warning=Generated module exports for {} public frameworks",
        frameworks.len()
    );
}

/// Generates a private_frameworks.rs file with module exports for all private frameworks
fn generate_private_framework_modules(frameworks: &[String], out_path: &Path) {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Private Framework Modules (auto-generated from TBD files)\n");
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// This file is automatically generated by frameworks.rs\n");
    output.push_str("// Do not edit manually - changes will be overwritten\n\n");

    for framework in frameworks {
        let module_name = framework.to_lowercase().replace("_", "").replace("-", "");
        let feature_name = module_name.replace(" ", "");

        output.push_str(&format!("#[cfg(feature = \"{}\")]\n", feature_name));
        output.push_str(&format!("pub mod {} {{\n", module_name));
        output.push_str(&format!(
            "    //! {} private framework (generated from TBD)\n",
            framework
        ));
        output.push_str("    #![allow(clippy::all)]\n");
        output.push_str("    #![allow(warnings)]\n");
        output.push_str(&format!(
            "    include!(concat!(env!(\"OUT_DIR\"), \"/{}.rs\"));\n",
            module_name
        ));
        output.push_str("}\n\n");
    }

    // Write the file
    fs::write(out_path.join("private_frameworks.rs"), output)
        .expect("Failed to write private_frameworks.rs");

    println!(
        "cargo:warning=Generated module exports for {} private frameworks",
        frameworks.len()
    );
}

pub fn main() {
    println!("cargo:rerun-if-changed=frameworks.rs");
    println!("cargo:rerun-if-changed=wrapper.h");

    let _target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    let _target_arch = env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();

    // Find iOS SDK from submodules
    let sdk_path = find_ios_sdk();

    if let Some(sdk) = &sdk_path {
        println!("cargo:warning=ios-sys: Using iOS SDK: {}", sdk.display());

        // Setup linker search paths (always)
        setup_linking(sdk);

        // Generate bindings from SDK headers
        generate_bindings(sdk);

        // Link frameworks if 'runtime' feature is enabled
        #[cfg(feature = "runtime")]
        {
            link_frameworks(sdk);
        }

        #[cfg(not(feature = "runtime"))]
        {
            println!("cargo:warning=ios-sys: Header-only mode (enable 'runtime' feature to link)");
        }
    } else {
        println!("cargo:warning=ios-sys: No iOS SDK found - cannot generate bindings!");
        println!("cargo:warning=To use Theos SDKs, clone them into submodules/sdks/");
        panic!("ios-sys requires iOS SDK in submodules/sdks/ to generate bindings");
    }
}

/// Find iOS SDK in submodules
fn find_ios_sdk() -> Option<PathBuf> {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    // Don't go to parent - submodules is in the same directory as Cargo.toml
    let sdk_dir = manifest_dir.join("submodules/sdks");

    if !sdk_dir.exists() {
        return None;
    }

    // Try to find the most recent iOS SDK
    let sdk_candidates = vec![
        "iPhoneOS16.5.sdk",
        "iPhoneOS15.6.sdk",
        "iPhoneOS14.5.sdk",
        "iPhoneOS13.7.sdk",
        "iPhoneOS12.4.sdk",
        "iPhoneOS11.4.sdk",
        "iPhoneOS10.3.sdk",
    ];

    for sdk_name in sdk_candidates {
        let sdk_path = sdk_dir.join(sdk_name);
        if sdk_path.exists() {
            return Some(sdk_path);
        }
    }

    None
}

/// Setup linking paths for iOS SDK
fn setup_linking(sdk_path: &Path) {
    // Add framework search paths
    println!(
        "cargo:rustc-link-search=framework={}/System/Library/Frameworks",
        sdk_path.display()
    );
    println!(
        "cargo:rustc-link-search=framework={}/System/Library/PrivateFrameworks",
        sdk_path.display()
    );

    // Add library search paths
    println!("cargo:rustc-link-search={}/usr/lib", sdk_path.display());
    println!(
        "cargo:rustc-link-search={}/usr/lib/system",
        sdk_path.display()
    );

    // Set sysroot for clang (used by bindgen)
    println!("cargo:rustc-env=IPHONEOS_SDK_PATH={}", sdk_path.display());
}

/// Get all available frameworks from SDK
fn get_all_frameworks(sdk_path: &Path) -> Vec<String> {
    let frameworks_dir = sdk_path.join("System/Library/Frameworks");

    if !frameworks_dir.exists() {
        return Vec::new();
    }

    let mut frameworks = Vec::new();

    if let Ok(entries) = fs::read_dir(&frameworks_dir) {
        for entry in entries.flatten() {
            if let Some(name) = entry.file_name().to_str() {
                if name.ends_with(".framework") {
                    let framework_name = name.trim_end_matches(".framework").to_string();
                    // Skip private/internal frameworks that start with underscore
                    if !framework_name.starts_with('_') {
                        frameworks.push(framework_name);
                    }
                }
            }
        }
    }

    frameworks.sort();
    frameworks
}

/// Get all private frameworks that have TBD files (no headers)
fn get_private_frameworks_with_tbd(sdk_path: &Path) -> Vec<String> {
    let private_frameworks_dir = sdk_path.join("System/Library/PrivateFrameworks");

    if !private_frameworks_dir.exists() {
        return Vec::new();
    }

    let mut frameworks = Vec::new();

    if let Ok(entries) = fs::read_dir(&private_frameworks_dir) {
        for entry in entries.flatten() {
            if let Some(name) = entry.file_name().to_str() {
                if name.ends_with(".framework") {
                    let framework_name = name.trim_end_matches(".framework").to_string();

                    // Check if TBD file exists
                    let tbd_path = entry.path().join(format!("{}.tbd", framework_name));
                    if tbd_path.exists() {
                        frameworks.push(framework_name);
                    }
                }
            }
        }
    }

    frameworks.sort();
    frameworks
}

/// Link iOS frameworks based on enabled features
#[cfg(feature = "runtime")]
fn link_frameworks(sdk_path: &Path) {
    // On macOS, use framework linking
    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-link-lib=framework=Foundation");
        println!("cargo:rustc-link-lib=framework=CoreFoundation");
        println!("cargo:rustc-link-lib=dylib=System");

        // Link all feature-gated frameworks
        link_feature_frameworks_macos();
    }

    // On other platforms (Linux cross-compiling), we need to explicitly link .tbd files
    #[cfg(not(target_os = "macos"))]
    {
        // libobjc is in /usr/lib/libobjc.tbd
        let libobjc_path = sdk_path.join("usr/lib/libobjc.tbd");
        if libobjc_path.exists() {
            println!("cargo:rustc-link-arg={}", libobjc_path.display());
        }

        // libSystem
        let libsystem_tbd = sdk_path.join("usr/lib/libSystem.tbd");
        if libsystem_tbd.exists() {
            println!("cargo:rustc-link-arg={}", libsystem_tbd.display());
        }

        let frameworks_dir = sdk_path.join("System/Library/Frameworks");

        // Always link core frameworks
        link_tbd_if_exists(&frameworks_dir, "Foundation");
        link_tbd_if_exists(&frameworks_dir, "CoreFoundation");
        link_tbd_if_exists(&frameworks_dir, "CoreGraphics");

        // Link all feature-gated frameworks
        link_feature_frameworks_linux(&frameworks_dir);
    }
}

#[cfg(all(feature = "runtime", target_os = "macos"))]
fn link_feature_frameworks_macos() {
    // Dynamically link all enabled framework features
    let frameworks = get_enabled_frameworks();
    for framework in frameworks {
        println!("cargo:rustc-link-lib=framework={}", framework);
    }
}

#[cfg(all(feature = "runtime", not(target_os = "macos")))]
fn link_feature_frameworks_linux(frameworks_dir: &Path) {
    let frameworks = get_enabled_frameworks();
    for framework in frameworks {
        link_tbd_if_exists(frameworks_dir, &framework);
    }
}

#[allow(dead_code)]
fn link_tbd_if_exists(frameworks_dir: &Path, framework_name: &str) {
    let tbd_path = frameworks_dir.join(format!(
        "{}.framework/{}.tbd",
        framework_name, framework_name
    ));
    if tbd_path.exists() {
        println!("cargo:rustc-link-arg={}", tbd_path.display());
    }
}

#[allow(dead_code)]
fn get_enabled_frameworks() -> Vec<String> {
    let mut frameworks = Vec::new();

    // Check each feature and add corresponding framework
    // We'll generate this list from ALL frameworks found in SDK
    let all_possible = vec![
        "Accelerate",
        "Accessibility",
        "Accounts",
        "ActivityKit",
        "AddressBook",
        "AddressBookUI",
        "AdServices",
        "AdSupport",
        "AppClip",
        "AppIntents",
        "AppTrackingTransparency",
        "ARKit",
        "AssetsLibrary",
        "AudioToolbox",
        "AudioUnit",
        "AuthenticationServices",
        "AutomatedDeviceEnrollment",
        "AutomaticAssessmentConfiguration",
        "AVFAudio",
        "AVFoundation",
        "AVKit",
        "AVRouting",
        "BackgroundAssets",
        "BackgroundTasks",
        "BusinessChat",
        "CallKit",
        "CarKey",
        "CarPlay",
        "CFNetwork",
        "Charts",
        "ClassKit",
        "ClockKit",
        "CloudKit",
        "ColorSync",
        "Combine",
        "Contacts",
        "ContactsUI",
        "CoreAudio",
        "CoreAudioKit",
        "CoreAudioTypes",
        "CoreBluetooth",
        "CoreData",
        "CoreHaptics",
        "CoreImage",
        "CoreLocation",
        "CoreLocationUI",
        "CoreMedia",
        "CoreMIDI",
        "CoreML",
        "CoreMotion",
        "CoreNFC",
        "CoreServices",
        "CoreSpotlight",
        "CoreTelephony",
        "CoreText",
        "CoreTransferable",
        "CoreVideo",
        "CreateML",
        "CreateMLComponents",
        "CryptoKit",
        "CryptoTokenKit",
        "DataDetection",
        "DeveloperToolsSupport",
        "DeviceActivity",
        "DeviceCheck",
        "DeviceDiscoveryExtension",
        "DriverKit",
        "EventKit",
        "EventKitUI",
        "ExposureNotification",
        "ExtensionFoundation",
        "ExtensionKit",
        "ExternalAccessory",
        "FamilyControls",
        "FileProvider",
        "FileProviderUI",
        "GameController",
        "GameKit",
        "GameplayKit",
        "GLKit",
        "GroupActivities",
        "GSS",
        "HealthKit",
        "HealthKitUI",
        "HomeKit",
        "iAd",
        "IdentityLookup",
        "IdentityLookupUI",
        "ImageCaptureCore",
        "ImageIO",
        "Intents",
        "IntentsUI",
        "IOKit",
        "IOSurface",
        "JavaScriptCore",
        "LinkPresentation",
        "LocalAuthentication",
        "LocalAuthenticationEmbeddedUI",
        "ManagedSettings",
        "ManagedSettingsUI",
        "MapKit",
        "Matter",
        "MatterSupport",
        "MediaAccessibility",
        "MediaPlayer",
        "MediaSetup",
        "MediaToolbox",
        "Messages",
        "MessageUI",
        "Metal",
        "MetalFX",
        "MetalKit",
        "MetalPerformanceShaders",
        "MetalPerformanceShadersGraph",
        "MetricKit",
        "MLCompute",
        "MobileCoreServices",
        "ModelIO",
        "MultipeerConnectivity",
        "MusicKit",
        "NaturalLanguage",
        "NearbyInteraction",
        "Network",
        "NetworkExtension",
        "NewsstandKit",
        "NotificationCenter",
        "OpenAL",
        "OpenGLES",
        "OSLog",
        "PassKit",
        "PDFKit",
        "PencilKit",
        "PHASE",
        "Photos",
        "PhotosUI",
        "ProximityReader",
        "PushKit",
        "PushToTalk",
        "QuickLook",
        "QuickLookThumbnailing",
        "RealityFoundation",
        "RealityKit",
        "ReplayKit",
        "RoomPlan",
        "SafariServices",
        "SafetyKit",
        "SceneKit",
        "ScreenTime",
        "SensorKit",
        "SharedWithYou",
        "SharedWithYouCore",
        "ShazamKit",
        "Social",
        "SoundAnalysis",
        "Speech",
        "SpriteKit",
        "StoreKit",
        "SwiftUI",
        "SystemConfiguration",
        "TabularData",
        "ThreadNetwork",
        "Twitter",
        "UIKit",
        "UniformTypeIdentifiers",
        "UserNotifications",
        "UserNotificationsUI",
        "VideoSubscriberAccount",
        "VideoToolbox",
        "Vision",
        "VisionKit",
        "WatchConnectivity",
        "WatchKit",
        "WeatherKit",
        "WebKit",
        "WidgetKit",
    ];

    for fw in all_possible {
        let feature_name = fw.to_lowercase().replace("_", "");
        if env::var(format!("CARGO_FEATURE_{}", feature_name.to_uppercase())).is_ok() {
            frameworks.push(fw.to_string());
        }
    }

    frameworks
}

/// Generate bindings using bindgen from SDK headers
fn generate_bindings(sdk_path: &Path) {
    let sysroot = format!("-isysroot{}", sdk_path.display());
    let include_path = format!("-I{}/usr/include", sdk_path.display());

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Common clang args
    let common_args = vec![
        sysroot.as_str(),
        include_path.as_str(),
        "-target",
        "arm64-apple-ios",
        "-fembed-bitcode",
    ];

    // Generate Objective-C runtime bindings (ALWAYS)
    println!("cargo:warning=Generating Objective-C runtime bindings...");
    let objc_bindings = bindgen::Builder::default()
        .header_contents(
            "objc_wrapper.h",
            r#"
#include <objc/runtime.h>
#include <objc/message.h>
#include <objc/objc.h>
            "#,
        )
        .clang_args(&common_args)
        .allowlist_function("objc_.*")
        .allowlist_function("sel_.*")
        .allowlist_function("class_.*")
        .allowlist_function("method_.*")
        .allowlist_function("object_.*")
        .allowlist_function("ivar_.*")
        .allowlist_function("protocol_.*")
        .allowlist_function("property_.*")
        .allowlist_type("objc_.*")
        .allowlist_type("Protocol")
        .allowlist_type("id")
        .allowlist_type("Class")
        .allowlist_type("SEL")
        .allowlist_type("IMP")
        .allowlist_type("Method")
        .allowlist_type("Ivar")
        .allowlist_type("Category")
        .allowlist_var("objc_.*")
        .allowlist_var("OBJC_.*")
        .derive_default(true)
        .derive_debug(true)
        .derive_copy(true)
        .use_core()
        .ctypes_prefix("::core::ffi")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .expect("Unable to generate objc bindings");

    objc_bindings
        .write_to_file(out_path.join("objc.rs"))
        .expect("Couldn't write objc bindings!");

    // Generate Mach kernel bindings (ALWAYS)
    println!("cargo:warning=Generating Mach kernel bindings...");
    let mach_bindings = bindgen::Builder::default()
        .header_contents(
            "mach_wrapper.h",
            r#"
#include <mach/mach.h>
#include <mach/task.h>
#include <mach/thread_act.h>
#include <mach/vm_map.h>
#include <mach/kern_return.h>
#include <mach/port.h>
#include <mach/boolean.h>
#include <mach/vm_prot.h>
#include <mach/vm_inherit.h>
            "#,
        )
        .clang_args(&common_args)
        .allowlist_function("mach_.*")
        .allowlist_function("task_.*")
        .allowlist_function("thread_.*")
        .allowlist_function("vm_.*")
        .allowlist_function("host_.*")
        .allowlist_function("port_.*")
        .allowlist_type("mach_.*")
        .allowlist_type("task_.*")
        .allowlist_type("thread_.*")
        .allowlist_type("vm_.*")
        .allowlist_type("kern_return_t")
        .allowlist_type("natural_t")
        .allowlist_type("integer_t")
        .allowlist_type("boolean_t")
        .allowlist_type("mach_port_.*")
        .allowlist_type("mach_msg_.*")
        .allowlist_type(".*_t")
        .allowlist_var("KERN_.*")
        .allowlist_var("VM_.*")
        .allowlist_var("MACH_.*")
        .allowlist_var("CPU_.*")
        .allowlist_var("MH_.*")
        .derive_default(true)
        .derive_debug(true)
        .derive_copy(true)
        .derive_eq(true)
        .derive_partialeq(true)
        .use_core()
        .ctypes_prefix("::core::ffi")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .generate()
        .expect("Unable to generate mach bindings");

    mach_bindings
        .write_to_file(out_path.join("mach.rs"))
        .expect("Couldn't write mach bindings!");

    // Generate Foundation bindings (ALWAYS)
    println!("cargo:warning=Generating Foundation bindings from runtime dump...");

    // Check if we have a class dump file (prefer comprehensive dump)
    let class_dump_path = if Path::new("/tmp/all_objc_classes.txt").exists() {
        Path::new("/tmp/all_objc_classes.txt")
    } else {
        Path::new("/tmp/foundation_classes.txt")
    };
    if class_dump_path.exists() {
        if let Err(e) = objc_codegen::generate_from_dump_file(
            class_dump_path,
            &out_path.join("foundation.rs")
        ) {
            println!("cargo:warning=Failed to generate from class dump: {}", e);
            println!("cargo:warning=Falling back to minimal Foundation bindings");
            generate_minimal_foundation_bindings(&out_path);
        }
    } else {
        println!("cargo:warning=No class dump found at /tmp/foundation_classes.txt");
        println!("cargo:warning=Run class_dump tool on device to generate full bindings");
        generate_minimal_foundation_bindings(&out_path);
    }

    // Generate CoreFoundation bindings (ALWAYS)
    println!("cargo:warning=Generating CoreFoundation bindings...");
    generate_framework_bindings(&common_args, &out_path, "CoreFoundation", "CF");

    // Generate CoreGraphics bindings (ALWAYS)
    println!("cargo:warning=Generating CoreGraphics bindings...");
    generate_framework_bindings(&common_args, &out_path, "CoreGraphics", "CG");

    // Get all PUBLIC frameworks from SDK
    let all_frameworks = get_all_frameworks(sdk_path);
    println!(
        "cargo:warning=Found {} frameworks in SDK",
        all_frameworks.len()
    );

    // Also scan for PRIVATE frameworks with TBD files
    let private_frameworks = get_private_frameworks_with_tbd(sdk_path);
    println!(
        "cargo:warning=Found {} private frameworks with TBD files",
        private_frameworks.len()
    );

    // Generate bindings for ALL frameworks (feature-gated)
    for framework in &all_frameworks {
        // Skip frameworks we already generated
        if framework == "CoreFoundation" || framework == "CoreGraphics" || framework == "Foundation"
        {
            continue;
        }

        let feature_name = framework.to_lowercase().replace("_", "");

        // Check if feature is enabled
        if env::var(format!("CARGO_FEATURE_{}", feature_name.to_uppercase())).is_ok() {
            println!("cargo:warning=Generating {} bindings...", framework);

            // Determine prefix (usually first 2-3 letters uppercase)
            let prefix = get_framework_prefix(&framework);

            generate_framework_bindings(&common_args, &out_path, &framework, &prefix);
        }
    }

    // Generate bindings from PRIVATE frameworks using TBD files
    // Note: We generate for ALL private frameworks found, not just feature-gated ones
    // This allows users to access any private framework without needing explicit features
    for framework in &private_frameworks {
        let module_name = framework.to_lowercase().replace("_", "");
        let feature_name = module_name.replace("-", "").replace(" ", "");

        // Check if this private framework feature is explicitly enabled
        // OR if "all-private" feature is enabled
        let feature_enabled =
            env::var(format!("CARGO_FEATURE_{}", feature_name.to_uppercase())).is_ok();
        let all_private_enabled = env::var("CARGO_FEATURE_ALLPRIVATE").is_ok();

        let should_generate = feature_enabled || all_private_enabled;

        if should_generate {
            println!(
                "cargo:warning=Generating {} bindings from TBD...",
                framework
            );

            let tbd_path = sdk_path
                .join("System/Library/PrivateFrameworks")
                .join(format!("{}.framework/{}.tbd", framework, framework));

            if let Some(tbd_info) = parse_tbd_file(&tbd_path) {
                println!(
                    "cargo:warning=  Found {} classes, {} symbols",
                    tbd_info.objc_classes.len(),
                    tbd_info.symbols.len()
                );
                generate_tbd_bindings(&tbd_info, &module_name, &out_path);
            } else {
                println!("cargo:warning=  Failed to parse TBD file");
            }
        }
    }

    // Generate public_frameworks.rs with all module exports
    generate_public_framework_modules(&all_frameworks, &out_path);

    // Generate private_frameworks.rs with all module exports
    generate_private_framework_modules(&private_frameworks, &out_path);

    println!("cargo:warning=Bindings generated successfully!");
}

fn get_framework_prefix(framework: &str) -> String {
    // Common framework prefixes
    match framework {
        "UIKit" => "UI".to_string(),
        "QuartzCore" => "CA".to_string(),
        "Security" => "Sec".to_string(),
        "AVFoundation" | "AVFAudio" | "AVKit" | "AVRouting" => "AV".to_string(),
        "CoreData" => "NS".to_string(), // CoreData uses NS prefix
        "Foundation" => "NS".to_string(),
        "Metal" | "MetalKit" | "MetalFX" => "MTL".to_string(),
        "SceneKit" => "SCN".to_string(),
        "SpriteKit" => "SK".to_string(),
        "GameKit" => "GK".to_string(),
        "MapKit" => "MK".to_string(),
        "WebKit" => "WK".to_string(),
        "HealthKit" => "HK".to_string(),
        "HomeKit" => "HM".to_string(),
        "CoreML" => "ML".to_string(),
        "Vision" => "VN".to_string(),
        "NaturalLanguage" => "NL".to_string(),
        "Speech" => "SF".to_string(),
        "Network" => "nw".to_string(),
        "IOKit" => "IO".to_string(),
        "ImageIO" => "CG".to_string(), // ImageIO uses CG prefix
        _ => {
            // Default: extract capital letters or first 2 chars
            let capitals: String = framework.chars().filter(|c| c.is_uppercase()).collect();
            if capitals.len() >= 2 {
                capitals
            } else {
                framework.chars().take(2).collect()
            }
        }
    }
}

fn generate_minimal_foundation_bindings(out_path: &Path) {
    let stub = r#"// Minimal Foundation bindings
// Run class_dump tool to generate full bindings

use crate::objc::{id, Class};

// Basic types
pub type NSInteger = isize;
pub type NSUInteger = usize;
pub type CGFloat = f64;

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct NSRange {
    pub location: NSUInteger,
    pub length: NSUInteger,
}

// Essential C functions
#[link(name = "Foundation", kind = "framework")]
unsafe extern "C" {
    pub fn NSLog(format: id, ...);
    pub fn NSClassFromString(aClassName: id) -> Class;
}
"#;
    fs::write(out_path.join("foundation.rs"), stub).expect("Failed to write Foundation stub");
}

fn generate_framework_bindings(
    common_args: &[&str],
    out_path: &Path,
    framework_name: &str,
    prefix: &str,
) {
    let header_content = format!("#include <{0}/{0}.h>", framework_name);
    let module_name = framework_name.to_lowercase().replace("_", "");

    // For Foundation, only generate C functions and basic types
    // Objective-C classes will be generated from runtime introspection
    let bindings = if framework_name == "Foundation" {
        bindgen::Builder::default()
            .header_contents(&format!("{}_wrapper.h", module_name), &header_content)
            .clang_args(common_args)
            // Only generate C functions, not ObjC classes
            .allowlist_function("NSLog")
            .allowlist_function("NSLog.*")
            .allowlist_function("NSClassFromString")
            .allowlist_function("NSSelectorFromString")
            .allowlist_function("NSStringFromClass")
            .allowlist_function("NSStringFromSelector")
            .allowlist_function("NSStringFromProtocol")
            .allowlist_function("NSProtocolFromString")
            .allowlist_function("NSStringFromRange")
            .allowlist_function("NSRangeFromString")
            .allowlist_function("NSMakeRange")
            .allowlist_function("NSEqualRanges")
            .allowlist_function("NSLocationInRange")
            .allowlist_function("NSUnionRange")
            .allowlist_function("NSIntersectionRange")
            // Constants
            .allowlist_var("k.*")
            .allowlist_var("NS.*")
            // Basic types (structs, enums, typedefs)
            .allowlist_type("NSInteger")
            .allowlist_type("NSUInteger")
            .allowlist_type("NSRange")
            .allowlist_type("NSPoint")
            .allowlist_type("NSSize")
            .allowlist_type("NSRect")
            .allowlist_type("CGFloat")
            .allowlist_type("CGPoint")
            .allowlist_type("CGSize")
            .allowlist_type("CGRect")
            .allowlist_type("NSComparisonResult")
            .allowlist_type("NSStringEncoding")
            .allowlist_type("UIEdgeInsets")
            .allowlist_type("UIOffset")
            .derive_default(true)
            .derive_debug(true)
            .derive_copy(true)
            .derive_eq(true)
            .derive_partialeq(true)
            .use_core()
            .ctypes_prefix("::core::ffi")
            .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
            .generate()
    } else {
        // For other frameworks, try normal generation
        bindgen::Builder::default()
            .header_contents(&format!("{}_wrapper.h", module_name), &header_content)
            .clang_args(common_args)
            .allowlist_type(&format!("{}.*", prefix))
            .allowlist_function(&format!("{}.*", prefix))
            .allowlist_var(&format!("k{}.*", prefix))
            .allowlist_var(&format!("{}.*", prefix))
            .derive_default(true)
            .derive_debug(true)
            .derive_copy(true)
            .use_core()
            .ctypes_prefix("::core::ffi")
            .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
            .generate()
    };

    match bindings {
        Ok(b) => {
            b.write_to_file(out_path.join(format!("{}.rs", module_name)))
                .expect(&format!("Couldn't write {} bindings!", framework_name));
        }
        Err(e) => {
            println!(
                "cargo:warning=Failed to generate {} bindings: {}",
                framework_name, e
            );
            println!("cargo:warning=Creating empty stub for {}", framework_name);

            // Create an empty module stub so compilation doesn't fail
            let stub_content = format!(
                "// Stub: {} framework bindings could not be generated\n\
                 // This framework requires more complex Objective-C parsing\n\
                 // or has dependencies that bindgen cannot resolve.\n\
                 //\n\
                 // To use this framework, you may need to:\n\
                 // 1. Use manual bindings\n\
                 // 2. Use higher-level Rust crates (objc2, block, etc.)\n\
                 // 3. Create wrapper functions in a .m file\n",
                framework_name
            );

            fs::write(out_path.join(format!("{}.rs", module_name)), stub_content)
                .expect(&format!("Couldn't write {} stub!", framework_name));
        }
    }
}
